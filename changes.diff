--- code/SAT_CDC_for_PCBv2.ino	2023-12-09 21:31:26.160486300 +0100
+++ code/SAT_CDC_MD_for_PCBv2.ino	2023-12-09 21:31:50.609233600 +0100
@@ -79,6 +79,10 @@
 #define CDC_BASE_ID 0xE8      //ID when getting commands from HU
 #define CDC_ALT_ID 0xE9       //Alternative ID when getting commands from HU
 
+#define MD_RESPONSE_ID 0xDE
+#define MD_MASTER_ID 0xDF
+#define MD_BASE_ID 0xD8
+#define MD_ALT_ID 0xD9
 
 byte textHeader[] = {0xFC, 0xC6, 0x73, 0x01};
 byte textRow = 2;
@@ -163,6 +167,7 @@
 //Defining the commands. First byte is the length of the command.
 #define MRB_1 {3, 0x00, 0x1C, 0xEC}            //Master Request Broadcast version 1
 #define MRB_2 {3, 0x00, 0x1E, 0xEC}            //Master Request Broadcast version 2 (maybe this is second init seq?)
+#define MRB_3 {3, 0x01, 0x18, 0xEC}            //Master request Broadcast version 3
 #define MI {3, 0x07, 0x1A, 0xEE}               //Main init sequence
 #define SI {3, 0x00, 0x1E, 0xED}               //Secondary init sequence (turn off ignition, then on)
 //changed from 00 1D ED
@@ -207,14 +212,90 @@
 //#define CDC_SI {0x00, 0x1C, 0xED},         //secondary init req. wait for BASE_ID and respond with RESPONSE_ID.
 //#define CDC_MRB {0x00, 0x1C, 0xEC}         //master req broadcast. wait for MASTER_ID and respond with MASTER_ID.
 
+#define MD_CIR {3, MD_BASE_ID, 0x1E, 0xEF}             //Cartridge info request. Respond with 6 bytes
+#define MD_TIR {5, MD_ALT_ID, 0x1B, 0xE0, 0x01, 0x08}  //track info req. resp 9 bytes
+#define MD_NXT {5, MD_BASE_ID, 0x1B, 0x2D, 0x40, 0x01} //next track.
+#define MD_PRV {5, MD_BASE_ID, 0x1B, 0x2D, 0x00, 0x01} //prev track
+#define MD_CHG {3, MD_BASE_ID, 0x1A, 0x50}             //change cd
+#define MD_PUP {3, MD_BASE_ID, 0x19, 0x2F}             //power up. resp ack (0x00).
+#define MD_PDN {3, MD_BASE_ID, 0x19, 0x22}             //power down. ack (0x00)
+#define MD_FFW {3, MD_BASE_ID, 0x19, 0x29}             //FFW. ack
+#define MD_FRW {3, MD_BASE_ID, 0x19, 0x26}             //FRW. ack
+#define MD_SCN {3, MD_BASE_ID, 0x19, 0x2E}             //scan mode. ack
+#define MD_RND {3, MD_BASE_ID, 0x19, 0x52}             //random mode. ack
+#define MD_NU {3, MD_BASE_ID, 0x1A, 0x50}              //not used
+
+#define MD_TEXT_ROW_1 0x01, 0x01, 0x03
+#define MD_TEXT_ROW_2 0x02, 0x02, 0x03
+#define MD_TEXT_ROW_3 0x03, 0x03, 0x03
+
+#define MD_RTR {7, MD_BASE_ID, 0x1E, 0xF9, MD_TEXT_ROW_1, 0x01}             //request text row respond with 2 bytes
+#define MD_RTR_2 {7, MD_BASE_ID, 0x1E, 0xF9, MD_TEXT_ROW_2, 0x01}        //request text row
+#define MD_RTR_3 {7, MD_BASE_ID, 0x1E, 0xF9, MD_TEXT_ROW_3, 0x01}        //request text row
+
+enum {
+  E_MRB_1,    // 0
+  E_MI,       // 1
+  E_SI,       // 2
+  E_CMD_1,    // 3 follows: [0, 92, FF], OR [1,3 ,FF] OR [2, 5 FF]
+  E_PUP,      // 4 wait 2 bytes and answer 0x90?
+  E_MRB_2,    // 5 alternative master req bc
+  E_MRB_3,
+  E_CMD_3,    // 6 unknown. Answer: 0x10, 0x80, 0x92
+  E_C1_1,     // 7 respond with c1_init_1
+  E_C1_2,     // 8 respond with c1_init_2 (contains text)
+  E_C3_0,     // 9 respond with c3_init_0
+  E_C3_1,     // 10 respond with c3_init_1
+  E_C3_2,     // 11 respond with c3_init_2
+  E_C2_0,     // 12 get next byte (nn) and respond with 10, 0, nn, 0,0 and 14 of 0x20
+  E_C2_1,     // 13
+  E_C5_1,     // 14
+  E_BTN,      // 15
+  E_NXT,      // 16
+  E_PRV,      // 17
+  E_SCN,      // 18
+  E_PWR_OFF,  // 19
+  E_PWR_SBY,  // 20
+  E_IGN_OFF,  // 21
+  E_CDC_CIR,  // 37
+  E_CDC_TIR,  // 38
+  E_CDC_NXT,  // 39
+  E_CDC_PRV,  // 40
+  E_CDC_CHG,  // 41
+  E_CDC_PUP,  // 42
+  E_CDC_PDN,  // 43
+  E_CDC_FFW,  // 44
+  E_CDC_FRW,  // 45
+  E_CDC_SCN,  // 46
+  E_CDC_RND,  // 47
+  E_CDC_NU,   // 48
+  E_MD_CIR,   // 22
+  E_MD_TIR,   // 23
+  E_MD_NXT,   // 24
+  E_MD_PRV,   // 25
+  E_MD_CHG,   // 26
+  E_MD_PUP,   // 27
+  E_MD_PDN,   // 28
+  E_MD_FFW,   // 29
+  E_MD_FRW,   // 30
+  E_MD_SCN,   // 31
+  E_MD_RND,   // 32
+  E_MD_RTR,   // 34
+  E_MD_RTR_2, // 35
+  E_MD_RTR_3, // 36
+  E_MD_NU,    // 33
+  E_LIST_MAX  // 49 handy entry which signifies the size of the command array
+};
+
 //This list can be quite long. We have approx 700 us between the received bytes.
-const byte commands[][7] = {
+const byte commands[][8] = {
   MRB_1,  // 0 now we are master and can send stuff (like text) to the display!
   MI,     // 1 main init
   SI,     // 2 sec init (00 1E ED respond 0xC5 !!)
   CMD_1,  // 3 follows: [0, 92, FF], OR [1,3 ,FF] OR [2, 5 FF]
   PUP,  // 4 wait 2 bytes and answer 0x90?
   MRB_2,  // 5 alternative master req bc
+  MRB_3,
   CMD_3,  // 6 unknown. Answer: 0x10, 0x80, 0x92
   C1_1,   // 7 respond with c1_init_1
   C1_2,   // 8 respond with c1_init_2 (contains text)
@@ -242,20 +323,66 @@
   CDC_FRW, // 30
   CDC_SCN, // 31
   CDC_RND, // 32
-  CDC_NU   // 33
+  CDC_NU,   // 33
+  MD_CIR,
+  MD_TIR,
+  MD_NXT,   // 24
+  MD_PRV,   // 25
+  MD_CHG,   // 26
+  MD_PUP,   // 27
+  MD_PDN,
+  MD_FFW,   // 29
+  MD_FRW,   // 30
+  MD_SCN,   // 31
+  MD_RND,   // 32
+  MD_RTR,   // 34
+  MD_RTR_2, // 35
+  MD_RTR_3, // 36
+  MD_NU    // 33
+};
+
+enum {
+  STATE_INVALID,
+  STATE_CDC,
+  STATE_MD,
+  STATE_SAT
 };
 
-const byte listLen = 34; //how many rows in the above array
+const byte listLen = E_LIST_MAX; //how many rows in the above array
 
+#define TEXTINIT_SIZE 11
+#define TEXTCMD_SIZE 27
+union text_cmd {
+  struct __PACKED {
+    byte header[4];
+    byte row;
+    byte row2;
+    byte row3;
+    byte row4;
+    byte footer[2];
+    byte track;
+    byte payload[16];
+  }text_cmd_st;
+  byte raw[TEXTCMD_SIZE];
+};
+
+byte current_state = 0;
 // some CDC (CD-CHANGER) data
-byte trackInfo[] = {0x00, 0x02, 0x00, cd, 0x80, track, 0xC7, 0x0A, 0x02}; //9 bytes
 byte startByte = 0x08; //on powerup - change trackInfo[1] & [8] to this
 byte stopByte = 0x02; //same on powerdown
-byte cartridgeInfo[] = {0x00, 0xFC, 0xFF, 0x4A, 0xFC, 0xFF};
-
-
-
-
+byte cdcTrackInfo[] = {0x00, 0x02, 0x00, 0x01, 0x80, 0x01, 0xC7, 0x0A, 0x02};
+byte cdcCartridgeInfo[] = {0x00, 0xFC, 0xFF, 0x4A, 0xFC, 0xFF};
+byte mdTrackInfo[] = {0x00, 0x02, 0x00, 0x00, 0x80, 0x99, 0x0C, 0xCC, 0xCC};
+byte mdCartridgeInfo[] = {0x80, 0x00, 0x0F, 0x04, 0x00, 0x0F};
+byte textInitHeader[] = {0xF9, 0xD8, 0xE1, 0x68, 0x00, 0x00, 0x40, 0x00, 0x0C, 0xCC, 0xCC }; // Send this as reply to first MRB2
+byte text_row_1[] = {0x03, 0x01, 0x03, 0x01};
+byte text_row_2[] = {0x03, 0x02, 0x03, 0x01};
+byte text_row_3[] = {MD_TEXT_ROW_3, 0x01};
+byte text_header_1[] = {MD_TEXT_ROW_1, 0x02};
+byte text_footer[] = {0x00, 0x80};
+union text_cmd text = { .raw = {0}};
+bool textInit = false;
+byte mdTextHeader[] = {0xFB, 0xD8, 0xFA, 0x00}; // Send this as prefix to text
 /*
  *      **** SETUP ****
 */
@@ -319,6 +446,7 @@
   static long ConnTicks = 0;    //age since last message to SIRIUS SAT
   static long timeout = 1000000; //should be around 10-20 secs
   static byte matching[listLen];     //Keep track of every matching byte in the commands array
+  static char text_array[17] = {0};
 
   //these variables are reset every loop
   byte byteCounter = 1;  //keep track of how many bytes is sent in current command
@@ -357,19 +485,35 @@
             ConnTicks = 0;  //reset age
 
             switch (cmd) {
-
-              //0, MRB_1
-              case 0:
+              case E_MRB_3:
+              case E_MRB_2:
+              case E_MRB_1:
                 //wait for master_id and respond with same
                 while (!(PIND & (1 << MELBUS_BUSY))) {
                   if (byteIsRead) {
                     byteIsRead = false;
-                    if (melbus_ReceivedByte == MASTER_ID) {
-                      byteToSend = MASTER_ID;
-                      SendByteToMelbus();
-                      SendText(textRow);
-                      //Serial.println("MRB1");
+                    if(current_state == STATE_SAT) {
+                      if (melbus_ReceivedByte == MASTER_ID) {
+                        byteToSend = MASTER_ID;
+                        SendByteToMelbus();
+                        SendText(textRow);
+                        //Serial.println("MRB1");
+                      }
+                    } else {
+                      if (melbus_ReceivedByte == MD_MASTER_ID) {
+                        byteToSend = MD_MASTER_ID;
+                        SendByteToMelbus();
+                        melbus_Bitposition = 7;
+                        SendText2(textInit);
+                                              if (textInit) {
+                        textInit = false;
+                        memcpy(text.raw, mdTextHeader, sizeof(mdTextHeader));
+                        memcpy(text.text_cmd_st.footer, text_footer, 2); // TODO: Change (all) anonymous arrays to something that's defined
+                        memcpy(&text.raw[sizeof(mdTextHeader)], text_header_1, 4);
+                        text.text_cmd_st.track = 0x99;
+                      }
                       break;
+                      }
                     }
                   }
                 }
@@ -377,7 +521,13 @@
                 break;
 
               //1, MAIN INIT
-              case 1:
+              case E_SI:
+              case E_MI:
+                textInitHeader[3] = 0x68;
+                textInitHeader[6] = 0x40;
+                textInitHeader[7] = 0x0;
+                memcpy(text.raw, textInitHeader, sizeof(textInitHeader));
+                reqMasterFlag = true;
                 //wait for base_id and respond with response_id
                 while (!(PIND & (1 << MELBUS_BUSY))) {
                   if (byteIsRead) {
@@ -390,31 +540,16 @@
                       byteToSend = CDC_RESPONSE_ID;
                       SendByteToMelbus();
                     }
-                  }
-                }
-                //Serial.println("main init");
-                break;
-
-              //2, Secondary INIT
-              case 2:
-                while (!(PIND & (1 << MELBUS_BUSY))) {
-                  if (byteIsRead) {
-                    byteIsRead = false;
-                    if (melbus_ReceivedByte == CDC_BASE_ID) {
-                      byteToSend = CDC_RESPONSE_ID;
-                      SendByteToMelbus();
-                    }
-                    if (melbus_ReceivedByte == BASE_ID) {
-                      byteToSend = RESPONSE_ID;
+                    if (melbus_ReceivedByte == MD_BASE_ID) {
+                      byteToSend = MD_RESPONSE_ID;
                       SendByteToMelbus();
                     }
                   }
                 }
-                //Serial.println("2nd init");
+                //Serial.println("main init");
                 break;
-
               //CMD_1. answer 0x10
-              case 3:
+              case E_CMD_1:
                 // we read 3 different tuple bytes (0x00 92), (01,3) and (02,5), response is always 0x10;
                 while (!(PIND & (1 << MELBUS_BUSY))) {
                   if (byteIsRead) {
@@ -433,7 +568,7 @@
 
 
               //PUP. power on?
-              case 4:
+              case E_PUP:
                 // {0xC0, 0x1C, 0x70, 0x02} we respond 0x90;
                 while (!(PIND & (1 << MELBUS_BUSY))) {
                   if (byteIsRead) {
@@ -447,30 +582,12 @@
                   }
                 }
                 //Serial.println("power on");
+                current_state = STATE_SAT;
                 digitalWrite(MISC, HIGH);
                 break;
 
-              //MRB_2
-              case 5:
-                // {00 1E EC };
-                //wait for master_id and respond with same
-                while (!(PIND & (1 << MELBUS_BUSY))) {
-                  if (byteIsRead) {
-                    byteIsRead = false;
-                    if (melbus_ReceivedByte == MASTER_ID) {
-                      byteToSend = MASTER_ID;
-                      SendByteToMelbus();
-                      SendText(textRow);
-                      //Serial.println("MRB2");
-                      break;
-                    }
-                  }
-                }
-                //Serial.println("MRB 2");
-                break;
-
               // CMD_3,  // 6 unknown. Answer: 0x10, 0x80, 0x92
-              case 6:
+              case E_CMD_3:
                 byteToSend = 0x10;
                 SendByteToMelbus();
                 byteToSend = 0x80;
@@ -481,7 +598,7 @@
                 break;
 
               //C1_1,    7 respond with c1_init_1
-              case 7:
+              case E_C1_1:
                 for (byte i = 0; i < SO_C1_Init_1; i++) {
                   byteToSend = C1_Init_1[i];
                   SendByteToMelbus();
@@ -490,7 +607,7 @@
                 break;
 
               //C1_2,   8 respond with c1_init_2 (contains text)
-              case 8:
+              case E_C1_2:
                 for (byte i = 0; i < SO_C1_Init_2; i++) {
                   byteToSend = C1_Init_2[i];
                   SendByteToMelbus();
@@ -499,7 +616,7 @@
                 break;
 
               //  C3_0,    9 respond with c3_init_0
-              case 9:
+              case E_C3_0:
                 for (byte i = 0; i < SO_C3_Init_0; i++) {
                   byteToSend = C3_Init_0[i];
                   SendByteToMelbus();
@@ -508,7 +625,7 @@
                 break;
 
               //C3_1,    10 respond with c3_init_1
-              case 10:
+              case E_C3_1:
                 for (byte i = 0; i < SO_C3_Init_1; i++) {
                   byteToSend = C3_Init_1[i];
                   SendByteToMelbus();
@@ -517,7 +634,7 @@
                 break;
 
               //C3_2,   11 respond with c3_init_2
-              case 11:
+              case E_C3_2:
                 for (byte i = 0; i < SO_C3_Init_2; i++) {
                   byteToSend = C3_Init_2[i];
                   SendByteToMelbus();
@@ -527,7 +644,7 @@
 
               //   C2_0,    12 get next byte (nn) and respond with 10, 0, nn, 0,0 and (14 times 0x20)
               // possibly a text field?
-              case 12:
+              case E_C2_0:
                 while (!(PIND & (1 << MELBUS_BUSY))) {
                   if (byteIsRead) {
                     byteIsRead = false;
@@ -553,7 +670,7 @@
                 break;
 
               //C2_1,    13 respond as 12
-              case 13:
+              case E_C2_1:
                 while (!(PIND & (1 << MELBUS_BUSY))) {
                   if (byteIsRead) {
                     byteIsRead = false;
@@ -579,7 +696,7 @@
                 break;
 
               //C5_1
-              case 14:
+              case E_C5_1:
                 while (!(PIND & (1 << MELBUS_BUSY))) {
                   if (byteIsRead) {
                     byteIsRead = false;
@@ -608,7 +725,7 @@
                 break;
 
               //BTN
-              case 15:
+              case E_BTN:
                 //wait for next byte to get CD number
                 while (!(PIND & (1 << MELBUS_BUSY))) {
                   if (byteIsRead) {
@@ -655,7 +772,7 @@
                 break;
 
               //NXT
-              case 16:
+              case E_NXT:
                 byteToSend = 0x00;  //no idea what to answer
                 SendByteToMelbus();
                 nextTrack();
@@ -663,7 +780,7 @@
                 break;
 
               //PRV
-              case 17:
+              case E_PRV:
                 byteToSend = 0x00;  //no idea what to answer
                 SendByteToMelbus();
                 prevTrack();
@@ -671,7 +788,7 @@
                 break;
 
               //SCN
-              case 18:
+              case E_SCN:
                 byteToSend = 0x00;  //no idea what to answer
                 SendByteToMelbus();
                 play();
@@ -679,7 +796,7 @@
                 break;
 
               //PWR OFF
-              case 19:
+              case E_PWR_OFF:
                 byteToSend = 0x00;  //no idea what to answer
                 SendByteToMelbus();
                 //Serial.println("Power down");
@@ -688,7 +805,7 @@
                 break;
 
               //PWR SBY
-              case 20:
+              case E_PWR_SBY:
                 byteToSend = 0x00;  //no idea what to answer
                 SendByteToMelbus();
                 //Serial.println("Power stby");
@@ -696,88 +813,149 @@
                 break;
 
               //IGN_OFF
-              case 21:
+              case E_IGN_OFF:
                 //Serial.println("Ignition OFF");
                 powerOn = false;
                 break;
 
               //
-              case 22:
-                SendCartridgeInfo();
+              case E_CDC_CIR:
+                SendCartridgeInfo(cdcCartridgeInfo);
                 break;
 
               //
-              case 23:
-                SendTrackInfo();
+              case E_CDC_TIR:
+                SendTrackInfo(cdcTrackInfo);
                 break;
 
               //
-              case 24:
+              case E_CDC_NXT:
                 track++;
                 fixTrack();
-                trackInfo[5] = track;
+                cdcTrackInfo[5] = track;
                 nextTrack();
                 break;
 
               //
-              case 25:
+              case E_CDC_PRV:
                 track--;
                 fixTrack();
-                trackInfo[5] = track;
+                cdcTrackInfo[5] = track;
                 prevTrack();
                 break;
 
               //
-              case 26:
+              case E_CDC_CHG:
                 changeCD();
                 break;
 
               //CDC_PUP
-              case 27:
+              case E_CDC_PUP:
                 byteToSend = 0x00;
                 SendByteToMelbus();
-                trackInfo[1] = startByte;
-                trackInfo[8] = startByte;
+                cdcTrackInfo[1] = startByte;
+                cdcTrackInfo[8] = startByte;
                 digitalWrite(MISC, HIGH);
+                current_state = STATE_CDC;
                 break;
 
               //CDC_PDN
-              case 28:
+              case E_CDC_PDN:
                 byteToSend = 0x00;
                 SendByteToMelbus();
-                trackInfo[1] = stopByte;
-                trackInfo[8] = stopByte;
+                cdcTrackInfo[1] = stopByte;
+                cdcTrackInfo[8] = stopByte;
                 digitalWrite(MISC, LOW);
                 break;
 
               //CDC_FFW
-              case 29:
+              case E_CDC_FFW:
                 byteToSend = 0x00;
                 SendByteToMelbus();
                 break;
 
               //CDC_FRW
-              case 30:
+              case E_CDC_FRW:
                 byteToSend = 0x00;
                 SendByteToMelbus();
                 break;
 
               //CDC_SCN
-              case 31:
+              case E_CDC_SCN:
                 byteToSend = 0x00;
                 SendByteToMelbus();
                 break;
 
               //CDC_RND
-              case 32:
+              case E_CDC_RND:
                 byteToSend = 0x00;
                 SendByteToMelbus();
                 play();
                 break;
-
+              case E_MD_NU:   // 33
               //CDC_NU
-              case 33:
-
+              case E_CDC_NU:
+                break;
+              case E_MD_CIR:
+                SendCartridgeInfo(mdCartridgeInfo);
+                break;
+              case E_MD_TIR:
+                SendTrackInfo(mdTrackInfo);
+                break;
+              case E_MD_RTR:   // 34
+                memcpy(&text.raw[4], text_row_1, 4);
+                fixText(text_array, "testText01");
+                memcpy(text.text_cmd_st.payload, text_array, sizeof(text.text_cmd_st.payload));
+                byteToSend = 0x00;
+                SendByteToMelbus();
+                byteToSend = 0x01;
+                SendByteToMelbus();
+                reqMasterFlag = true;
+                break;
+              case E_MD_RTR_2: // 35
+                memcpy(&text.raw[4], text_row_2, 4);
+                fixText(text_array, "testText02");
+                memcpy(text.text_cmd_st.payload, text_array, sizeof(text.text_cmd_st.payload));
+                byteToSend = 0x00;
+                SendByteToMelbus();
+                byteToSend = 0x01;
+                SendByteToMelbus();
+                reqMasterFlag = true;
+                break;
+              case E_MD_RTR_3: // 36
+                memcpy(&text.raw[4], text_row_3, 4);
+                fixText(text_array, "testText03");
+                memcpy(text.text_cmd_st.payload, text_array, sizeof(text.text_cmd_st.payload));
+                byteToSend = 0x00;
+                SendByteToMelbus();
+                byteToSend = 0x01;
+                SendByteToMelbus();
+                reqMasterFlag = true;
+                break;
+              case E_MD_NXT:
+              case E_MD_PRV:   // 25
+              case E_MD_CHG:   // 26
+                byteToSend = 0x00;
+                SendByteToMelbus();
+                break;
+              case E_MD_PUP:   // 27
+                mdTrackInfo[1] = startByte;
+                mdTrackInfo[6] = mdTrackInfo[7] = mdTrackInfo[8] = 0;
+                current_state = STATE_MD;
+              case E_MD_PDN:   // 28
+                if (cmd == E_MD_PDN) {
+                    mdTrackInfo[1] = stopByte;
+                    mdTrackInfo[6] = 0xC;
+                    mdTrackInfo[7] = mdTrackInfo[8] = 0xCC;
+                }
+                reqMasterFlag = true;
+                textInit = true;
+              case E_MD_FFW:   // 29
+              case E_MD_FRW:   // 30
+              case E_MD_SCN:   // 31
+              case E_MD_RND:   // 32
+                byteToSend = 0x00;
+                SendByteToMelbus();
                 break;
 
             } //end switch
@@ -870,10 +1048,19 @@
                 END LOOP
 */
 
+void fixText(char text[17], const char *input) {
+    size_t inputLength = strlen(input);
 
-
-
-
+    if (inputLength >= 16) {
+        strncpy(text, input, 16); // Copy up to 16 characters
+    } else {
+        strcpy(text, input);      // Copy the input string
+        for (size_t i = inputLength; i < 16; ++i) {
+            text[i] = ' ';        // Pad with spaces
+        }
+    }
+    text[16] = '\0';
+}
 
 //Notify HU that we want to trigger the first initiate procedure to add a new device
 //(CD-CHGR/SAT etc) by pulling BUSY line low for 1s
@@ -962,7 +1149,24 @@
   delayMicroseconds(20);
 }
 
-
+//This method generates our own clock AND drives busy low. Used in master mode in MD-CHGR mode
+void SendByteToMelbus3() {
+  delayMicroseconds(527);
+  for (char i = 7; i >= 0; i--) {
+    PORTD &= ~(1 << MELBUS_CLOCKBIT);  //clock -> low
+    delayMicroseconds(8);
+    if (byteToSend & (1 << i)) {
+      PORTD |= (1 << MELBUS_DATA);
+    } else {
+      PORTD &= ~(1 << MELBUS_DATA);
+    }
+    PORTD |= (1 << MELBUS_CLOCKBIT);   //clock -> high
+    //wait for output to settle
+    delayMicroseconds(8);
+    //wait for HU to read the bit
+  }
+  delayMicroseconds(20);
+}
 
 //Global external interrupt that triggers when clock pin goes high after it has been low for a short time => time to read datapin
 void MELBUS_CLOCK_INTERRUPT() {
@@ -1035,6 +1239,44 @@
   Serial.println("  END");
 }
 
+void SendText2(bool init) {
+
+  //Convert busypin, datapin and clockpin to output
+  //pinMode(MELBUS_DATA, OUTPUT); //To slow, use DDRD instead:
+  PORTD &= ~(1 << MELBUS_BUSY);  //set BUSY input_pullup => LOW when output (active)
+  DDRD |= (1 << MELBUS_BUSY);
+  PORTD |= 1 << MELBUS_DATA;      //set DATA input_pullup => HIGH when output (idle)
+  DDRD |= (1 << MELBUS_DATA);     //set DATA as output
+      //Disable interrupt on INT_NUM quicker than: detachInterrupt(MELBUS_CLOCKBIT_INT);
+  EIMSK &= ~(1 << INT_NUM);
+  PORTD |= 1 << MELBUS_CLOCKBIT;  //set CLK input_pullup => HIGH when output (idle)
+  DDRD |= (1 << MELBUS_CLOCKBIT); //set CLK as output
+
+  uint8_t size = TEXTCMD_SIZE;
+  if (init) {
+    uint8_t size = TEXTINIT_SIZE;
+  }
+
+  for (uint8_t b = 0; b < size; b++) {
+    byteToSend = text.raw[b];
+    SendByteToMelbus3();
+  }
+
+
+  DDRD &= ~(1 << MELBUS_CLOCKBIT);//back to input (PULLUP since we clocked in the last bit with clk = high)
+  //Reset datapin to high and return it to an input
+  //pinMode(MELBUS_DATA, INPUT_PULLUP);
+  PORTD |= 1 << MELBUS_DATA;  //this may or may not change the state, depending on the last transmitted bit
+  DDRD &= ~(1 << MELBUS_DATA);//release the data line
+  //Clear INT flag
+  EIFR |= 1 << INT_NUM;
+  //Enable interrupt on INT_NUM, quicker than: attachInterrupt(MELBUS_CLOCKBIT_INT, MELBUS_CLOCK_INTERRUPT, RISING);
+  EIMSK |= (1 << INT_NUM);
+  
+  PORTD |= 1 << MELBUS_BUSY;  //busy back high
+  DDRD &= ~(1 << MELBUS_BUSY);//release the busy line
+//  ResetMasterToSlave();
+}
 
 void reqMaster() {
   DDRD |= (1 << MELBUS_DATA); //output
@@ -1220,20 +1462,25 @@
       }
     }
   }
-  trackInfo[3] = cd;
-  trackInfo[5] = track;
+  if (cd > 10) {
+    cd = 1;
+  } else if (cd < 1) {
+    cd = 10;
+  }
+  cdcTrackInfo[3] = cd;
+  cdcTrackInfo[5] = track;
 }
 
-void SendTrackInfo() {
+void SendTrackInfo(byte trackInfo2[]) {
   for (byte i = 0; i < 9; i++) {
-    byteToSend = trackInfo[i];
+    byteToSend = trackInfo2[i];
     SendByteToMelbus();
   }
 }
 
-void SendCartridgeInfo() {
+void SendCartridgeInfo(byte cartridgeInfo2[]) {
   for (byte i = 0; i < 6; i++) {
-    byteToSend = cartridgeInfo[i];
+    byteToSend = cartridgeInfo2[i];
     SendByteToMelbus();
   }
 }
@@ -1248,4 +1495,3 @@
 
 
 //Happy listening AND READING, hacker!
-
